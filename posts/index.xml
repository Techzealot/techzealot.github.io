<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 个人博客</title><link>https://techzealot.github.io/posts/</link><description>Recent content in Posts on 个人博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 03 Mar 2023 17:47:56 +0800</lastBuildDate><atom:link href="https://techzealot.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>ServiceMesh总结</title><link>https://techzealot.github.io/posts/servicemesh%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 03 Mar 2023 17:47:56 +0800</pubDate><guid>https://techzealot.github.io/posts/servicemesh%E6%80%BB%E7%BB%93/</guid><description>基础架构
流量管理
参考资料
Service Mesh 实战</description></item><item><title>Docker知识总结</title><link>https://techzealot.github.io/posts/docker%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 03 Mar 2023 17:46:31 +0800</pubDate><guid>https://techzealot.github.io/posts/docker%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid><description>容器的本质 namesapce和cgroup
容器里 1 号进程对信号处理的两个要点 在容器中，1 号进程永远不会响应 SIGKILL 和 SIGSTOP 这两个特权信号；</description></item><item><title>学习资料整理</title><link>https://techzealot.github.io/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/</link><pubDate>Thu, 18 Aug 2022 13:48:59 +0800</pubDate><guid>https://techzealot.github.io/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/</guid><description>数据结构 书籍:
Java高并发与集合框架：JCF和JUC源码分析与实现
视频:
恋上数据结构第一季
玩转数据结构 从入门到进阶(慕课网)
算法 kotlin go rust</description></item><item><title>PriorityQueue源码分析</title><link>https://techzealot.github.io/posts/priorityqueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Thu, 11 Aug 2022 13:55:39 +0800</pubDate><guid>https://techzealot.github.io/posts/priorityqueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>本质是一个最小二叉堆,底层使用数组进行存储
使用到的二叉堆性质:(n为二叉堆节点个数,数组从索引0开始存储,从上到下从左到右从0开始依次编号)
节点i若有左右孩子，则左孩子索引为(i&amp;laquo;1)+1,右孩子索引为(i&amp;laquo;1)+2
第一个叶子结点的索引为size&amp;raquo;1,最后一个非叶子节点索引为(size&amp;raquo;1)-1
节点i的父节点为(i-1)&amp;raquo;1,若(i&amp;laquo;1)+1 &amp;gt;=size(无左孩子)则该节点一定为叶子结点
叶子结点在数组后半段且从第一个叶子结点开始后续全都是叶子结点
初始化注意事项:</description></item><item><title>ArrayDeque源码分析</title><link>https://techzealot.github.io/posts/arraydeque%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Thu, 11 Aug 2022 13:55:08 +0800</pubDate><guid>https://techzealot.github.io/posts/arraydeque%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>本质: 循环数组，支持双端存取
JDK8中底层数组的大小必须为2的n次幂有多个好处:
2.1 方便按顺序遍历数组中所有元素
int mask=elements.</description></item><item><title>领域驱动设计笔记</title><link>https://techzealot.github.io/posts/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/</link><pubDate>Thu, 11 Aug 2022 13:54:21 +0800</pubDate><guid>https://techzealot.github.io/posts/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/</guid><description>领域 DDD 的领域就是这个边界内要解决的业务问题域。
子域 我们把划分出来的多个子领域称为子域，每个子域对应一个更小的问题域或更小的业务范围。
在领域不断划分的过程中，领域会细分为不同的子域，子域可以根据自身重要性和功能属性划
分为三类子域，它们分别是：核心域、通用域和支撑域
核心域、支撑域和通用域的主要目标是：通过领域划分，区分不同子域在公司内的不同功能属
性和重要性，从而公司可对不同子域采取不同的资源投入和建设策略，其关注度也会不一样
通用语言定义上下文含义，限界上下文则定义领域边界</description></item><item><title>LinkedList源码分析</title><link>https://techzealot.github.io/posts/linkedlist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Fri, 05 Aug 2022 17:59:57 +0800</pubDate><guid>https://techzealot.github.io/posts/linkedlist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description> 本质: 双向链表 序列化时仅需要按顺序序列化元素本身无需序列化Node，只需要在反序列化时重建双向链表即可 不推荐作为Deque,Queue,Stack(不允许存储null)使用,因为LinkedList可以存储null,不符合取出元素返回null时集合为空的接口定义</description></item><item><title>ArrayList源码分析</title><link>https://techzealot.github.io/posts/arraylist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Fri, 05 Aug 2022 17:59:47 +0800</pubDate><guid>https://techzealot.github.io/posts/arraylist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description> 本质:底层使用数组，超出数组容量后会扩容50%并将数据拷贝到新数组对应位置 序列化的优化:仅序列化存有元素的数据,不序列化未使用数组部分 使用modCount做简化的并发检测，并不能做到并发安全，可以控制使用迭代器时无法修改集合，仅能通过迭代器提供的操作进行处理 Collection#toArray接口要求返回一个新的存有集合数据的数组，不能返回底层数组防止被意外修改影响原集合功能</description></item><item><title>idea测试覆盖率使用</title><link>https://techzealot.github.io/posts/idea%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87%E4%BD%BF%E7%94%A8/</link><pubDate>Wed, 22 Dec 2021 14:25:05 +0800</pubDate><guid>https://techzealot.github.io/posts/idea%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87%E4%BD%BF%E7%94%A8/</guid><description>单个测试覆盖率
直接选择&amp;quot;Run with Coverage&amp;quot;即可
所有测试的覆盖率(gradle)
在gradle插件中找到test任务(Tasks/verification/test),右键test选择&amp;quot;Run with Coverage&amp;quot;即可</description></item></channel></rss>