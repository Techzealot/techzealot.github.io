<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 个人博客</title><link>https://techzealot.github.io/posts/</link><description>Recent content in Posts on 个人博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 27 Apr 2023 15:08:40 +0800</lastBuildDate><atom:link href="https://techzealot.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>常见事务管理器综述</title><link>https://techzealot.github.io/posts/%E5%B8%B8%E8%A7%81%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E7%BB%BC%E8%BF%B0/</link><pubDate>Thu, 27 Apr 2023 15:08:40 +0800</pubDate><guid>https://techzealot.github.io/posts/%E5%B8%B8%E8%A7%81%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E7%BB%BC%E8%BF%B0/</guid><description>常见事务管理器综述 事务管理器功能 开启事务 提交事务 回滚事务 管理多个关联事务 spring事务管理器设计 事务管理器接口定义为PlatformTransactionManager,默认实现为DataSourceTransactionManager，通过Connection接口提供的功能实现事务相关功能的管理,其本身不具备事务功能</description></item><item><title>Seata</title><link>https://techzealot.github.io/posts/seata/</link><pubDate>Fri, 14 Apr 2023 17:55:23 +0800</pubDate><guid>https://techzealot.github.io/posts/seata/</guid><description>seata 分布式事务简介 分布式事务产生的根本原因 组成业务逻辑的一组操作使用的数据库连接不是同一个
CAP理论(布鲁尔定理) 分布式系统中无法同时满足CAP
Consistency 一致性 一致性指all nodes see the same data at the same time，即所有节点在同一时间的数据完全一致。</description></item><item><title>Mysql事务</title><link>https://techzealot.github.io/posts/mysql%E4%BA%8B%E5%8A%A1/</link><pubDate>Mon, 03 Apr 2023 17:57:34 +0800</pubDate><guid>https://techzealot.github.io/posts/mysql%E4%BA%8B%E5%8A%A1/</guid><description>mysql事务详解 本文所有讨论皆是针对innodb存储引擎
锁 锁分类 表锁模式兼容矩阵
InnoDB锁分类
InnoDB锁关系矩阵
行锁算法 不同索引加锁行为分析 InnoDB存储引擎的行锁是通过锁住索引实现的，而不是记录</description></item><item><title>Spring循环依赖与三级缓存</title><link>https://techzealot.github.io/posts/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%B8%8E%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/</link><pubDate>Tue, 28 Mar 2023 23:15:17 +0800</pubDate><guid>https://techzealot.github.io/posts/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%B8%8E%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/</guid><description>spring循环依赖与三级缓存 单例对象三级缓存出处 //org.springframework.beans.factory.support.DefaultSingletonBeanRegistry /** Cache of singleton objects: bean name to bean instance.</description></item><item><title>字符串常量池</title><link>https://techzealot.github.io/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/</link><pubDate>Tue, 28 Mar 2023 15:14:46 +0800</pubDate><guid>https://techzealot.github.io/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/</guid><description>Java字符串常量池 本文讨论的是JDK8及之后的版本
内存模型的变化 jdk8之后字符串常量池从Perm区转移到堆中
intern机制的变化 如果字符串常量池中存在(StringTable在比较时equals返回true)，则返回该字符串对象地址；
如果字符串常量池中不存在，则返回调用intern的字符串对象在堆中的地址，达到复用该对象
字符串常量池的添加方式 通过双引号字符串声明添加 //创建一个对象 String s = &amp;#34;test&amp;#34;; //创建hello,world两个字符串常量池中对象，两个栈中中间变量，一个堆中最终变量&amp;#34;helloworld&amp;#34;,注意此字符串不在常量池中 String s = new String(&amp;#34;hello&amp;#34;) + new String(&amp;#34;world&amp;#34;); 通过intern方法添加 //常量池不存在时 String s = new String(&amp;#34;hello&amp;#34;) + new String(&amp;#34;world&amp;#34;); s.</description></item><item><title>Spring Aop</title><link>https://techzealot.github.io/posts/spring-aop/</link><pubDate>Mon, 20 Mar 2023 16:09:36 +0800</pubDate><guid>https://techzealot.github.io/posts/spring-aop/</guid><description>Spring AOP AOP实现模式 动态代理
jdk cglib AspectJ静态代理
aspectj compiler AOP失效 动态代理模式下</description></item><item><title>数据库软删除设计</title><link>https://techzealot.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E5%88%A0%E9%99%A4%E8%AE%BE%E8%AE%A1/</link><pubDate>Thu, 16 Mar 2023 17:05:07 +0800</pubDate><guid>https://techzealot.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E5%88%A0%E9%99%A4%E8%AE%BE%E8%AE%A1/</guid><description>软删除设计 常见方案 使用删除标识字段，通常为布尔类型（mysql tinyint）
使用delete_at时间类型字段，默认值为空，代表未删除，不为空则代表删除时间
优点：实现简单方便，框架支持较好</description></item><item><title>Spring事务</title><link>https://techzealot.github.io/posts/spring%E4%BA%8B%E5%8A%A1/</link><pubDate>Thu, 16 Mar 2023 16:58:08 +0800</pubDate><guid>https://techzealot.github.io/posts/spring%E4%BA%8B%E5%8A%A1/</guid><description>spring事务 声明式事务 声明式事务底层由spring AOP支持
引入依赖spring-boot-starter-jdbc即可使用开箱即用的声明式事务支持
@Service public class OrderService { @Autowired private StoreService storeService; @Transactional(rollbackFor = Exception.</description></item><item><title>JUC</title><link>https://techzealot.github.io/posts/juc/</link><pubDate>Tue, 14 Mar 2023 17:04:24 +0800</pubDate><guid>https://techzealot.github.io/posts/juc/</guid><description>JUC JUC知识体系 mindmap root(juc) base unasfe varhandle atomic AtomicInteger AtomicBoolean AtomicLong AtomicReference AtomicStampedReference AtomicMarkablereference AtomicXXXArray AtomicXXXFiledUpdater LongAdder/DoubleAdder LongAccumulator/DoubleAccumulator Locks AQS ReentrantLock ReentrantReadWriteLock StampedLock uitls CountdownLatch CyclicBarrier Semaphore Exchanger Phaser Containers BlockingQueue ArrayBlockingQueue LinkedBlockingQueue PriorityBlockingQueue SynchronusQueue DelayQueue BlockingDeque LinkedBlockingDeque CopyOnWrite CopyOnWriteArrayList CopyOnWriteArraySet Concurrent ConcurrentLinkedDeque ConcurrentLinkedQueue ConcurrentSkipListSet ConcurrentSkipListMap ConcurrentHashMap ThreadPool ThreadPoolExecutor ScheduledThreadPoolExecutor ForkJoinPool Async Future Promise CompletableFuture Synchronized 使用wait/notifyAll,Lock/Condition实现阻塞队列 实现锁的核心要素 为了实现一把具有阻塞或唤醒功能的锁，需要几个核心要素：</description></item><item><title>sharding sphere</title><link>https://techzealot.github.io/posts/sharding-sphere/</link><pubDate>Tue, 14 Mar 2023 16:50:52 +0800</pubDate><guid>https://techzealot.github.io/posts/sharding-sphere/</guid><description>sharding-sphere 兼容JDBC规范 常见接口：
如何阅读源码 微内核架构及实现 可参考dubbo spi的增强：
按需加载</description></item><item><title>ServiceMesh总结</title><link>https://techzealot.github.io/posts/servicemesh%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 03 Mar 2023 17:47:56 +0800</pubDate><guid>https://techzealot.github.io/posts/servicemesh%E6%80%BB%E7%BB%93/</guid><description>service mesh总结 基础架构 流量管理 参考资料
Service Mesh 实战</description></item><item><title>Docker知识总结</title><link>https://techzealot.github.io/posts/docker%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 03 Mar 2023 17:46:31 +0800</pubDate><guid>https://techzealot.github.io/posts/docker%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid><description>docker知识总结 容器的本质 namesapce和cgroup
容器里 1 号进程对信号处理的两个要点 在容器中，1 号进程永远不会响应 SIGKILL 和 SIGSTOP 这两个特权信号；</description></item><item><title>K8S知识总结</title><link>https://techzealot.github.io/posts/k8s%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 03 Mar 2023 17:46:14 +0800</pubDate><guid>https://techzealot.github.io/posts/k8s%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid><description>k8s知识总结 容器 容器本身没有价值，有价值的是“容器编排”
Cgroups技术 是用来制造约束的主要手段，而 Namespace技术 则是用来修改进程视图的主要方法
Mount Namespace跟其他Namespace的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效
挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）</description></item><item><title>PriorityQueue源码分析</title><link>https://techzealot.github.io/posts/priorityqueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Thu, 11 Aug 2022 13:55:39 +0800</pubDate><guid>https://techzealot.github.io/posts/priorityqueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>本质是一个最小二叉堆,底层使用数组进行存储
使用到的二叉堆性质:(n为二叉堆节点个数,数组从索引0开始存储,从上到下从左到右从0开始依次编号)
节点i若有左右孩子，则左孩子索引为(i&amp;laquo;1)+1,右孩子索引为(i&amp;laquo;1)+2
第一个叶子结点的索引为size&amp;raquo;1,最后一个非叶子节点索引为(size&amp;raquo;1)-1
节点i的父节点为(i-1)&amp;raquo;1,若(i&amp;laquo;1)+1 &amp;gt;=size(无左孩子)则该节点一定为叶子结点
叶子结点在数组后半段且从第一个叶子结点开始后续全都是叶子结点
初始化注意事项:</description></item><item><title>ArrayDeque源码分析</title><link>https://techzealot.github.io/posts/arraydeque%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Thu, 11 Aug 2022 13:55:08 +0800</pubDate><guid>https://techzealot.github.io/posts/arraydeque%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>本质: 循环数组，支持双端存取
JDK8中底层数组的大小必须为2的n次幂有多个好处:
2.1 方便按顺序遍历数组中所有元素
int mask=elements.</description></item><item><title>领域驱动设计笔记</title><link>https://techzealot.github.io/posts/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/</link><pubDate>Thu, 11 Aug 2022 13:54:21 +0800</pubDate><guid>https://techzealot.github.io/posts/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/</guid><description>领域驱动设计笔记 领域 DDD 的领域就是这个边界内要解决的业务问题域。
子域 我们把划分出来的多个子领域称为子域，每个子域对应一个更小的问题域或更小的业务范围。
在领域不断划分的过程中，领域会细分为不同的子域，子域可以根据自身重要性和功能属性划
分为三类子域，它们分别是：核心域、通用域和支撑域
核心域、支撑域和通用域的主要目标是：通过领域划分，区分不同子域在公司内的不同功能属
性和重要性，从而公司可对不同子域采取不同的资源投入和建设策略，其关注度也会不一样</description></item><item><title>Disruptor</title><link>https://techzealot.github.io/posts/disruptor/</link><pubDate>Wed, 19 Apr 2023 15:09:49 +0800</pubDate><guid>https://techzealot.github.io/posts/disruptor/</guid><description/></item><item><title>Http</title><link>https://techzealot.github.io/posts/http/</link><pubDate>Fri, 14 Apr 2023 11:37:06 +0800</pubDate><guid>https://techzealot.github.io/posts/http/</guid><description>参考资料
对线面试官：HTTP协议
对线面试官：postman 中 form-data、x-www-form-urlencoded 的区别</description></item><item><title>Rocketmq</title><link>https://techzealot.github.io/posts/rocketmq/</link><pubDate>Thu, 13 Apr 2023 18:41:22 +0800</pubDate><guid>https://techzealot.github.io/posts/rocketmq/</guid><description>参考资料
Spring Boot集成RocketMq如何发送多个事务消息</description></item><item><title>Cglib源码解析</title><link>https://techzealot.github.io/posts/cglib%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Thu, 06 Apr 2023 10:21:06 +0800</pubDate><guid>https://techzealot.github.io/posts/cglib%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description/></item><item><title>Asm源码解析</title><link>https://techzealot.github.io/posts/asm%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Thu, 06 Apr 2023 10:20:54 +0800</pubDate><guid>https://techzealot.github.io/posts/asm%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description/></item><item><title>Hugo增加mermaid支持</title><link>https://techzealot.github.io/posts/hugo%E5%A2%9E%E5%8A%A0mermaid%E6%94%AF%E6%8C%81/</link><pubDate>Fri, 31 Mar 2023 16:19:44 +0800</pubDate><guid>https://techzealot.github.io/posts/hugo%E5%A2%9E%E5%8A%A0mermaid%E6%94%AF%E6%8C%81/</guid><description>hugo增加mermaid绘图支持 hugo增加自定义功能的方式 customjs 在config.toml中增加配置
custom_css = [&amp;#34;css/custom.css&amp;#34;] custom_js = [&amp;#34;js/custom.</description></item><item><title>Springboot</title><link>https://techzealot.github.io/posts/springboot/</link><pubDate>Fri, 17 Mar 2023 18:48:20 +0800</pubDate><guid>https://techzealot.github.io/posts/springboot/</guid><description>springboot知识总结 bootstrap phase bootstrap阶段是springboot中为应用容器准备启动环境的阶段。该阶段最先运行，会产生BootstrapContext，为ApplicationContext准备配置文件，加载其他需要资源。BootstrapContext为ApplicationContext的父容器，其中的配置属性和Bean对于子容器均可见。该阶段会读取bootstrap.yml(properties)配置文件并存储于BootstrapContext，以便与ApplicationContext相关配置隔离。
应用：
配置远程配置中心地址并从中获取应用配置，如Apollo和spring cloud config 可以作为测试上下文所需资源的承载环境，如**testcontainers-spring-boot** 注意事项：</description></item><item><title>JCF</title><link>https://techzealot.github.io/posts/jcf/</link><pubDate>Tue, 14 Mar 2023 17:04:06 +0800</pubDate><guid>https://techzealot.github.io/posts/jcf/</guid><description/></item><item><title>知识体系</title><link>https://techzealot.github.io/posts/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</link><pubDate>Tue, 14 Mar 2023 17:02:33 +0800</pubDate><guid>https://techzealot.github.io/posts/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</guid><description>知识体系 java知识体系 mindmap root(java) JCF JUC Thread Atomic Concurrent 网络 BIO NIO AIO IO JVM GC Test junit spock testcontainers 框架 spring mybatis netty 微服务 dubbo springcloud cloudnative graalvm kotlin知识体系 groovy知识体系 go知识体系 rust知识体系 C知识体系 C++知识体系 python知识体系 haskell知识体系</description></item><item><title>GC</title><link>https://techzealot.github.io/posts/gc/</link><pubDate>Tue, 14 Mar 2023 17:00:40 +0800</pubDate><guid>https://techzealot.github.io/posts/gc/</guid><description>CMS
G1
ZGC</description></item><item><title>JVM</title><link>https://techzealot.github.io/posts/jvm/</link><pubDate>Tue, 14 Mar 2023 17:00:36 +0800</pubDate><guid>https://techzealot.github.io/posts/jvm/</guid><description/></item><item><title>线程池</title><link>https://techzealot.github.io/posts/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Tue, 14 Mar 2023 16:59:32 +0800</pubDate><guid>https://techzealot.github.io/posts/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description/></item><item><title>Netty</title><link>https://techzealot.github.io/posts/netty/</link><pubDate>Tue, 14 Mar 2023 16:57:24 +0800</pubDate><guid>https://techzealot.github.io/posts/netty/</guid><description>netty知识总结 TCP粘包与拆包 主从reactor线程模型 零拷贝 操作系统级：
FileRegion：底层FileChannel.transferTo JVM:
使用堆外内存,避免堆内内存到堆外内存的拷贝(系统调用必须使用堆外内存) API级:</description></item><item><title>Elasticsearch</title><link>https://techzealot.github.io/posts/elasticsearch/</link><pubDate>Tue, 14 Mar 2023 16:57:12 +0800</pubDate><guid>https://techzealot.github.io/posts/elasticsearch/</guid><description/></item><item><title>Sentinel</title><link>https://techzealot.github.io/posts/sentinel/</link><pubDate>Tue, 14 Mar 2023 16:56:13 +0800</pubDate><guid>https://techzealot.github.io/posts/sentinel/</guid><description>常见限流算法
固定窗口
滑动窗口
漏桶
令牌桶</description></item><item><title>Skywalking</title><link>https://techzealot.github.io/posts/skywalking/</link><pubDate>Tue, 14 Mar 2023 16:56:00 +0800</pubDate><guid>https://techzealot.github.io/posts/skywalking/</guid><description>要点
插件机制：
自定义类加载器:
Java agent ：bytebuddy
OpenTracing规范:</description></item><item><title>MySQL</title><link>https://techzealot.github.io/posts/mysql/</link><pubDate>Tue, 14 Mar 2023 16:55:39 +0800</pubDate><guid>https://techzealot.github.io/posts/mysql/</guid><description>mysql innodb存储引擎 体系结构
实例层
物理层
核心特性
索引 锁 参见mysql事务
事务 参见mysql事务</description></item><item><title>消息队列</title><link>https://techzealot.github.io/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Tue, 14 Mar 2023 16:54:53 +0800</pubDate><guid>https://techzealot.github.io/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description>RocketMQ
kafka</description></item><item><title>分布式协调算法</title><link>https://techzealot.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E7%AE%97%E6%B3%95/</link><pubDate>Tue, 14 Mar 2023 16:54:04 +0800</pubDate><guid>https://techzealot.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E7%AE%97%E6%B3%95/</guid><description>zab
raft</description></item><item><title>分布式锁</title><link>https://techzealot.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link><pubDate>Tue, 14 Mar 2023 16:50:30 +0800</pubDate><guid>https://techzealot.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid><description>实现原理
redisson实现</description></item><item><title>分布式事务</title><link>https://techzealot.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</link><pubDate>Tue, 14 Mar 2023 16:48:34 +0800</pubDate><guid>https://techzealot.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</guid><description>分布式事务 分布式事务模式总结 方案 简介 事务分类 一致性 总结 实现 / 产品 / 框架 两阶段提交（2PC） 二阶段分别指的是准备和提交两个阶段 数据库层面 强一致性 锁资源 - 阻塞 - 效率低 Seata 三阶段提交（3PC） 准备阶段、预提交阶段和提交阶段 数据库层面 强一致性 引入一个阶段也多一个交互，因此性能会差一些 TCC（补偿事务） TCC 指的是 Try - Confirm - Cancel 业务层面 最终一致性 执行效率高，基于 TCC 实现分布式事务，会将原来只需要一个接口就可以实现的逻辑拆分为 Try、Confirm、Cancel 三个接口，所以代码实现复杂度相对较高。 Seata Saga 模式 Saga 是一个长活事务可被分解成可以交错运行的子事务集合。其中每个子事务都是一个保持数据库一致性的真实事务 业务层面 最终一致性 一阶段提交本地事务，无锁，高性能 事件驱动架构，参与者可异步执行，高吞吐 补偿服务易于实现不保证隔离性 Seata 最大努力通知 柔性事务的思想：尽力最大的努力达成事务的最终一致；直接传递消息消费，要是成功则成功，要是失败则多重试几次，还是不成功就算了 业务层面 最终一致性 适用于对时间不敏感的业务；最大努力通知事务方案既没有使用本地表扫描，也未使用可靠消息机制,一般会提供主动查询接口 本地消息表 本地消息表其实就是利用了 各系统本地的事务来实现分布式事务 业务层面 最终一致性 此方案的核心是将需要分布式处理的任务通过消息日志表的方式来异步执行，执行成功后修改消息的状态；此外另起一个线程，不断轮询本地消息表中未处理成功的消息再次发起调用。与 tcc 相比，实现方式较为简单，开发成本低。缺点： 事务业务与消息发送业务耦合 、业务数据与消息表要在一起 MQ 消息事务 RocketMQ 事务消息的功能 业务层面 最终一致性 该方案与本地消息最大的不同是去掉了本地消息表，由 MQ 来实现消息的可靠性传递，确认消息一定被消费。业务相对简单，不需要编写三个阶段业务 缺点：代码侵入,还需要编写回查接口， 依赖于 MQ 的可靠性.</description></item><item><title>缓存</title><link>https://techzealot.github.io/posts/%E7%BC%93%E5%AD%98/</link><pubDate>Tue, 14 Mar 2023 16:27:43 +0800</pubDate><guid>https://techzealot.github.io/posts/%E7%BC%93%E5%AD%98/</guid><description>缓存 Redis 常见数据结构
缓存淘汰策略
rdb与aof
常见缓存问题及解决方案 缓存雪崩 缓存穿透 bloomfilter
缓存击穿 缓存一致性问题及解决方案 延时双删</description></item><item><title>分布式ID</title><link>https://techzealot.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8Fid/</link><pubDate>Tue, 14 Mar 2023 15:44:58 +0800</pubDate><guid>https://techzealot.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8Fid/</guid><description>分布式ID简介 雪花算法 美团Leaf 号段模式 改进的雪花算法 redis随机自增 参考资料
Leaf——美团点评分布式ID生成系统
分布式唯一 ID 生成方案浅谈</description></item><item><title>精品学习资料</title><link>https://techzealot.github.io/posts/%E7%B2%BE%E5%93%81%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</link><pubDate>Thu, 18 Aug 2022 13:48:59 +0800</pubDate><guid>https://techzealot.github.io/posts/%E7%B2%BE%E5%93%81%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</guid><description>精品学习资料 数据结构 书籍:
Java高并发与集合框架：JCF和JUC源码分析与实现
视频:
恋上数据结构第一季
玩转数据结构 从入门到进阶(慕课网)
DDD DDD（领域驱动设计）思想解读及优秀实践</description></item><item><title>LinkedList源码分析</title><link>https://techzealot.github.io/posts/linkedlist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Fri, 05 Aug 2022 17:59:57 +0800</pubDate><guid>https://techzealot.github.io/posts/linkedlist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description> 本质: 双向链表 序列化时仅需要按顺序序列化元素本身无需序列化Node，只需要在反序列化时重建双向链表即可 不推荐作为Deque,Queue,Stack(不允许存储null)使用,因为LinkedList可以存储null,不符合取出元素返回null时集合为空的接口定义</description></item><item><title>ArrayList源码分析</title><link>https://techzealot.github.io/posts/arraylist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Fri, 05 Aug 2022 17:59:47 +0800</pubDate><guid>https://techzealot.github.io/posts/arraylist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description> 本质:底层使用数组，超出数组容量后会扩容50%并将数据拷贝到新数组对应位置 序列化的优化:仅序列化存有元素的数据,不序列化未使用数组部分 使用modCount做简化的并发检测，并不能做到并发安全，可以控制使用迭代器时无法修改集合，仅能通过迭代器提供的操作进行处理 Collection#toArray接口要求返回一个新的存有集合数据的数组，不能返回底层数组防止被意外修改影响原集合功能</description></item><item><title>idea测试覆盖率使用</title><link>https://techzealot.github.io/posts/idea%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87%E4%BD%BF%E7%94%A8/</link><pubDate>Wed, 22 Dec 2021 14:25:05 +0800</pubDate><guid>https://techzealot.github.io/posts/idea%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87%E4%BD%BF%E7%94%A8/</guid><description>单个测试覆盖率
直接选择&amp;quot;Run with Coverage&amp;quot;即可
所有测试的覆盖率(gradle)
在gradle插件中找到test任务(Tasks/verification/test),右键test选择&amp;quot;Run with Coverage&amp;quot;即可</description></item></channel></rss>