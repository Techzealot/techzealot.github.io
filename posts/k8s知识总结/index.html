<!doctype html><html class=no-js lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>K8S知识总结 - 个人博客</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="K8S知识总结"><meta property="og:description" content="k8s知识总结 容器 容器本身没有价值，有价值的是“容器编排”
Cgroups技术 是用来制造约束的主要手段，而 Namespace技术 则是用来修改进程视图的主要方法
Mount Namespace跟其他Namespace的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效
挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）"><meta property="og:type" content="article"><meta property="og:url" content="https://techzealot.github.io/posts/k8s%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-03T17:46:14+08:00"><meta property="article:modified_time" content="2023-03-03T17:46:14+08:00"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title=个人博客 rel=home><div class="logo__item logo__text"><div class=logo__title>个人博客</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>菜单</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>首页</span></a></li><li class=menu__item><a class=menu__link href=/categories><span class=menu__text>分类</span></a></li><li class=menu__item><a class=menu__link href=/tags><span class=menu__text>标签</span></a></li><li class=menu__item><a class=menu__link href=/about><span class=menu__text>关于</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>K8S知识总结</h1><div class="post__meta meta"><div class="meta__item-author meta__item"><svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2.0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class=meta__text>techzealot</span></div><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-03-03T17:46:14+08:00>2023-03-03</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/k8s/ rel=category>k8s</a>, <a class=meta__link href=/categories/%E5%AE%B9%E5%99%A8/ rel=category>容器</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>目录</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#容器>容器</a></li><li><a href=#全局架构>全局架构</a></li><li><a href=#核心功能全景图>核心功能全景图</a></li><li><a href=#emptydir>emptyDir</a></li><li><a href=#为什么我们需要pod>为什么我们需要Pod</a></li><li><a href=#pod对象>pod对象</a></li><li><a href=#容器健康检查和恢复机制>容器健康检查和恢复机制</a></li><li><a href=#podpresetpod预设置>PodPreset（Pod预设置）</a></li><li><a href=#控制器>控制器</a><ul><li><a href=#deployment>Deployment</a></li><li><a href=#statefulset>StatefulSet</a></li><li><a href=#容器化守护进程daemonset>容器化守护进程DaemonSet</a></li></ul></li></ul></nav></div></div><div class="content post__content clearfix"><h1 id=k8s知识总结>k8s知识总结</h1><h2 id=容器>容器</h2><p>容器本身没有价值，有价值的是“容器编排”</p><p><strong>Cgroups技术</strong> 是用来制造约束的主要手段，而 <strong>Namespace技术</strong> 则是用来修改进程视图的主要方法</p><p>Mount Namespace跟其他Namespace的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效</p><p>挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）</p><p>rootfs只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在Linux操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。</p><p>所以说，rootfs只包括了操作系统的“躯壳”，并没有包括操作系统的“灵魂”。那么，对于容器来说，这个操作系统的“灵魂”又在哪里呢？</p><p><strong>实际上，同一台机器上的所有容器，都共享宿主机操作系统的内核。</strong></p><p>这就意味着，如果你的应用程序需要配置内核参数、加载额外的内核模块，以及跟内核进行直接的交互，你就需要注意了：这些操作和依赖的对象，都是宿主机操作系统的内核，它对于该机器上的所有容器来说是一个“全局变量”，牵一发而动全身</p><p>容器镜像的本质：rootfs+unionfs</p><p>一个进程，可以选择加入到某个进程已有的Namespace当中，从而达到“进入”这个进程所在容器的目的，这正是docker exec的实现原理</p><p>容器Volume里的信息，并不会被docker commit提交掉；但这个挂载点目录本身，则会出现在新的镜像当中</p><p>一个正在运行的Linux容器，其实可以被“一分为二”地看待：</p><ol><li><p>一组联合挂载在/var/lib/docker/aufs/mnt上的rootfs，这一部分我们称为“容器镜像”（Container Image），是容器的静态视图；</p></li><li><p>一个由Namespace+Cgroups构成的隔离环境，这一部分我们称为“容器运行时”（Container Runtime），是容器的动态视图。</p></li></ol><h2 id=全局架构>全局架构</h2><p><img src=https://techzealot.oss-cn-beijing.aliyuncs.com/img/image-20230308111043857.png alt=image-20230308111043857></p><h2 id=核心功能全景图>核心功能全景图</h2><p><img src=https://techzealot.oss-cn-beijing.aliyuncs.com/img/image-20230308113435340.png alt=image-20230308113435340></p><h2 id=emptydir>emptyDir</h2><p>什么是emptyDir类型呢？</p><p>它其实就等同于我们之前讲过的Docker的隐式Volume参数，即：不显式声明宿主机目录的Volume。所以，Kubernetes也会在宿主机上创建一个临时目录，这个目录将来就会被绑定挂载到容器所声明的Volume目录上。</p><p>不难看到，Kubernetes的emptyDir类型，只是把Kubernetes创建的临时目录作为Volume的宿主机目录，交给了Docker。这么做的原因，是Kubernetes不想依赖Docker自己创建的那个_data目录。</p><h2 id=为什么我们需要pod>为什么我们需要Pod</h2><p><strong>Pod这个概念，提供的是一种编排思想，而不是具体的技术方案</strong></p><p>Pod，实际上是在扮演传统基础设施里“虚拟机”的角色；而容器，则是这个虚拟机里运行的用户程序。</p><p>容器的本质是进程，pod相当于进程组，k8s就是操作系统</p><p>关于Pod最重要的一个事实是：它只是一个逻辑概念。**</p><p>也就是说，Kubernetes真正处理的，还是宿主机操作系统上Linux容器的Namespace和Cgroups，而并不存在一个所谓的Pod的边界或者隔离环境</p><p>Pod，其实是一组共享了某些资源的容器。</p><p>Pod里的所有容器，共享的是同一个Network Namespace，并且可以声明共享同一个Volume</p><p>在Kubernetes项目里，Pod的实现需要使用一个中间容器，这个容器叫作Infra容器。在这个Pod中，Infra容器永远都是第一个被创建的容器，而其他用户定义的容器，则通过Join Network Namespace的方式，与Infra容器关联在一起。这样的组织关系，可以用下面这样一个示意图来表达：</p><p><img src=https://techzealot.oss-cn-beijing.aliyuncs.com/img/image-20230308161837524.png alt=image-20230308161837524></p><p>如上图所示，这个Pod里有两个用户容器A和B，还有一个Infra容器。很容易理解，在Kubernetes项目里，Infra容器一定要占用极少的资源，所以它使用的是一个非常特殊的镜像，叫作： <code>k8s.gcr.io/pause</code>。这个镜像是一个用汇编语言编写的、永远处于“暂停”状态的容器，解压后的大小也只有100~200 KB左右。</p><p>而在Infra容器“Hold住”Network Namespace后，用户容器就可以加入到Infra容器的Network Namespace当中了。所以，如果你查看这些容器在宿主机上的Namespace文件（这个Namespace文件的路径，我已经在前面的内容中介绍过），它们指向的值一定是完全一样的。</p><p>这也就意味着，对于Pod里的容器A和容器B来说：</p><ul><li>它们可以直接使用localhost进行通信；</li><li>它们看到的网络设备跟Infra容器看到的完全一样；</li><li>一个Pod只有一个IP地址，也就是这个Pod的Network Namespace对应的IP地址；</li><li>当然，其他的所有网络资源，都是一个Pod一份，并且被该Pod中的所有容器共享；</li><li>Pod的生命周期只跟Infra容器一致，而与容器A和B无关。</li></ul><p>而对于同一个Pod里面的所有用户容器来说，它们的进出流量，也可以认为都是通过Infra容器完成的。这一点很重要，因为 <strong>将来如果你要为Kubernetes开发一个网络插件时，应该重点考虑的是如何配置这个Pod的Network Namespace，而不是每一个用户容器如何使用你的网络配置，这是没有意义的。</strong></p><p>容器设计模式-sidecar模式</p><p>sidecar指的就是我们可以在一个Pod中，启动一个辅助容器，来完成一些独立于主进程（主容器）之外的工作。</p><h2 id=pod对象>pod对象</h2><p>Pod，而不是容器，才是Kubernetes项目中的最小编排单位。</p><p>到底哪些属性属于Pod对象，而又有哪些属性属于Container呢？</p><p>如果你能把Pod看成传统环境里的“机器”、把容器看作是运行在这个“机器”里的“用户程序”，那么很多关于Pod对象的设计就非常容易理解了</p><p><strong>凡是调度、网络、存储，以及安全相关的属性，基本上是Pod 级别的。</strong></p><p><strong>凡是跟容器的Linux Namespace相关的属性，也一定是Pod 级别的</strong></p><p>Init Containers的生命周期，会先于所有的Containers，并且严格按照定义的顺序执行。</p><p>postStart定义的操作，虽然是在Docker容器ENTRYPOINT执行之后，但它并不严格保证顺序。也就是说，在postStart启动时，ENTRYPOINT有可能还没有结束。</p><p>preStop发生的时机，则是容器被杀死之前（比如，收到了SIGKILL信号）。而需要明确的是，preStop操作的执行，是同步的。所以，它会阻塞当前的容器杀死流程，直到这个Hook定义操作完成之后，才允许容器被杀死，这跟postStart不一样</p><p>在Kubernetes中，有几种特殊的Volume，它们存在的意义不是为了存放容器里的数据，也不是用来进行容器和宿主机之间的数据交换。这些特殊Volume的作用，是为容器提供预先定义好的数据。所以，从容器的角度来看，这些Volume里的信息就是仿佛是 <strong>被Kubernetes“投射”（Project）进入容器当中的</strong>。这正是Projected Volume的含义。</p><p>到目前为止，Kubernetes支持的Projected Volume一共有四种：</p><ol><li><p>Secret；</p></li><li><p>ConfigMap</p></li><li><p>Downward API；</p></li><li><p>ServiceAccountToken</p></li></ol><p><strong>与Secret类似的是ConfigMap</strong>，它与Secret的区别在于，ConfigMap保存的是不需要加密的、应用所需的配置信息</p><p>其实，Secret、ConfigMap，以及Downward API这三种Projected Volume定义的信息，大多还可以通过环境变量的方式出现在容器里。但是，通过环境变量获取这些信息的方式，不具备自动更新的能力。所以，一般情况下，我都建议你使用Volume文件的方式获取这些信息。</p><p>Kubernetes项目的Projected Volume其实只有三种，因为第四种ServiceAccountToken，只是一种特殊的Secret而已。</p><h2 id=容器健康检查和恢复机制>容器健康检查和恢复机制</h2><p>存活探针</p><p>就绪探针</p><p>Kubernetes中并没有Docker的Stop语义。所以虽然是Restart（重启），但实际却是重新创建了容器。</p><p>这个功能就是Kubernetes里的 <strong>Pod恢复机制</strong>，也叫restartPolicy。它是Pod的Spec部分的一个标准字段（pod.spec.restartPolicy），默认值是Always，即：任何时候这个容器发生了异常，它一定会被重新创建。</p><p>但一定要强调的是，Pod的恢复过程，永远都是发生在当前节点上，而不会跑到别的节点上去。事实上，一旦一个Pod与一个节点（Node）绑定，除非这个绑定发生了变化（pod.spec.node字段被修改），否则它永远都不会离开这个节点。这也就意味着，如果这个宿主机宕机了，这个Pod也不会主动迁移到其他节点上去。</p><p>restartPolicy：</p><ul><li>Always：在任何情况下，只要容器不在运行状态，就自动重启容器；（长期运行的应用）</li><li>OnFailure: 只在容器 异常时才自动重启容器；（单次运行的job）</li><li>Never: 从来不重启容器。（保留容器现场）</li></ul><p>如果你要关心这个容器退出后的上下文环境，比如容器退出后的日志、文件和目录，就需要将restartPolicy设置为Never。因为一旦容器被自动重新创建，这些内容就有可能丢失掉了（被垃圾回收了）</p><h2 id=podpresetpod预设置>PodPreset（Pod预设置）</h2><p>专门用来对Pod进行批量化、自动化修改的工具对象</p><p><strong>PodPreset里定义的内容，只会在Pod API对象被创建之前追加在这个对象本身上，而不会影响任何Pod的控制器的定义。</strong></p><p>比如，我们现在提交的是一个nginx-deployment，那么这个Deployment对象本身是永远不会被PodPreset改变的，被修改的只是这个Deployment创建出来的所有Pod。</p><p>如果你定义了同时作用于一个Pod对象的多个PodPreset，会发生什么呢？</p><p>实际上，Kubernetes项目会帮你合并（Merge）这两个PodPreset要做的修改。而如果它们要做的修改有冲突的话，这些冲突字段就不会被修改。</p><h2 id=控制器>控制器</h2><p>控制器模式：用一种对象管理另一种对象</p><p>通用编排模式：控制循环（control loop）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>实际状态</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>获取集群中对象X的实际状态</span><span style=color:#960050;background-color:#1e0010>（</span><span style=color:#a6e22e>Actual</span> <span style=color:#a6e22e>State</span><span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>期望状态</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>获取集群中对象X的期望状态</span><span style=color:#960050;background-color:#1e0010>（</span><span style=color:#a6e22e>Desired</span> <span style=color:#a6e22e>State</span><span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>实际状态</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>期望状态</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>什么都不做</span>
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>执行编排动作</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>将实际状态调整为期望状态</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以Deployment为例，我和你简单描述一下它对控制器模型的实现：</p><ol><li><p>Deployment控制器从Etcd中获取到所有携带了“app: nginx”标签的Pod，然后统计它们的数量，这就是实际状态；</p></li><li><p>Deployment对象的Replicas字段的值就是期望状态；</p></li><li><p>Deployment控制器将两个状态做比较，然后根据比较结果，确定是创建Pod，还是删除已有的Pod</p></li></ol><p>控制器定义模式</p><p><img src=https://techzealot.oss-cn-beijing.aliyuncs.com/img/image-20230309165645858.png alt=image-20230309165645858></p><p>如上图所示， <strong>类似Deployment这样的一个控制器，实际上都是由上半部分的控制器定义（包括期望状态），加上下半部分的被控制对象的模板组成的</strong></p><h3 id=deployment>Deployment</h3><p><strong>一个ReplicaSet对象，其实就是由副本数目的定义和一个Pod模板组成的</strong>。不难发现，它的定义其实是Deployment的一个子集。</p><p><strong>更重要的是，Deployment控制器实际操纵的，正是这样的ReplicaSet对象，而不是Pod对象。</strong></p><p>对于一个Deployment所管理的Pod，它的ownerReference是谁？这个问题的答案就是：ReplicaSet</p><p>Deployment，与ReplicaSet，以及Pod的关系：</p><p><img src=https://techzealot.oss-cn-beijing.aliyuncs.com/img/image-20230309170500553.png alt=image-20230309170500553></p><p>扩展Deployment、ReplicaSet和Pod的关系图</p><p><img src=https://techzealot.oss-cn-beijing.aliyuncs.com/img/image-20230309171725382.png alt=image-20230309171725382></p><p>Deployment的控制器，实际上控制的是ReplicaSet的数目，以及每个ReplicaSet的属性。</p><p>而一个应用的版本，对应的正是一个ReplicaSet；这个版本应用的Pod数量，则由ReplicaSet通过它自己的控制器（ReplicaSet Controller）来保证。</p><p>通过这样的多个ReplicaSet对象，Kubernetes项目就实现了对多个“应用版本”的描述</p><p>合并对deployment的多次更新或暂停滚动更新操作</p><ol><li>kubectl rollout pause</li><li>kubectl rollout resume</li></ol><p>在这个kubectl rollout resume指令执行之前，在kubectl rollout pause指令之后的这段时间里，我们对Deployment进行的所有修改，最后只会触发一次“滚动更新”</p><p>该如何控制这些“历史”ReplicaSet的数量呢？</p><p>很简单，Deployment对象有一个字段，叫作spec.revisionHistoryLimit，就是Kubernetes为Deployment保留的“历史版本”个数。所以，如果把它设置为0，你就再也不能做回滚操作了。</p><h3 id=statefulset>StatefulSet</h3><h4 id=拓扑状态>拓扑状态</h4><p>实例之间有不对等关系，以及实例对外部数据有依赖关系的应用，就被称为“有状态应用”（Stateful Application）</p><p>StatefulSet的设计其实非常容易理解。它把真实世界里的应用状态，抽象为了两种情况：</p><ol><li><p><strong>拓扑状态</strong>。这种情况意味着，应用的多个实例之间不是完全对等的关系。这些应用实例，必须按照某些顺序启动，比如应用的主节点A要先于从节点B启动。而如果你把A和B两个Pod删除掉，它们再次被创建出来时也必须严格按照这个顺序才行。并且，新创建出来的Pod，必须和原来Pod的网络标识一样，这样原先的访问者才能使用同样的方法，访问到这个新Pod。</p></li><li><p><strong>存储状态</strong>。这种情况意味着，应用的多个实例分别绑定了不同的存储数据。对于这些应用实例来说，Pod A第一次读取到的数据，和隔了十分钟之后再次读取到的数据，应该是同一份，哪怕在此期间Pod A被重新创建过。这种情况最典型的例子，就是一个数据库应用的多个存储实例。</p></li></ol><p>所以， <strong>StatefulSet的核心功能，就是通过某种方式记录这些状态，然后在Pod被重新创建时，能够为新Pod恢复这些状态。</strong></p><p>Headless Service不需要分配一个VIP，而是可以直接以DNS记录的方式解析出被代理Pod的IP地址。</p><p>所谓的Headless Service，其实仍是一个标准Service的YAML文件。只不过，它的clusterIP字段的值是：None，即：这个Service，没有一个VIP作为“头”。这也就是Headless的含义。所以，这个Service被创建后并不会被分配一个VIP，而是会以DNS记录的方式暴露出它所代理的Pod</p><p>当你创建了一个Headless Service之后，它所代理的所有Pod的IP地址，都会被绑定一个这样格式的DNS记录，如下所示：</p><pre tabindex=0><code>&lt;pod-name&gt;.&lt;svc-name&gt;.&lt;namespace&gt;.svc.cluster.local
</code></pre><p>这个DNS记录，正是Kubernetes项目为Pod分配的唯一的“可解析身份”（Resolvable Identity）。</p><p>有了这个“可解析身份”，只要你知道了一个Pod的名字，以及它对应的Service的名字，你就可以非常确定地通过这条DNS记录访问到Pod的IP地址。</p><p>StatefulSet给它所管理的所有Pod的名字，进行了编号，编号规则是：</p><p><code>&lt;statefulset name>-&lt;ordinal index></code>。</p><p>而且这些编号都是从0开始累加，与StatefulSet的每个Pod实例一一对应，绝不重复。更重要的是，这些Pod的创建，也是严格按照编号顺序进行的。</p><p>当我们把Pod删除之后，Kubernetes会按照原先编号的顺序，创建出了新的Pod。并且，Kubernetes依然为它们分配了与原来相同的“网络身份”；</p><p>通过这种严格的对应规则， <strong>StatefulSet就保证了Pod网络标识的稳定性</strong></p><p>通过这种方法， <strong>Kubernetes就成功地将Pod的拓扑状态（比如：哪个节点先启动，哪个节点后启动），按照Pod的“名字+编号”的方式固定了下来</strong>。此外，Kubernetes还为每一个Pod提供了一个固定并且唯一的访问入口，即：这个Pod对应的DNS记录。</p><p>这些状态，在StatefulSet的整个生命周期里都会保持不变，绝不会因为对应Pod的删除或者重新创建而失效。</p><p>不过，相信你也已经注意到了，尽管这条DNS记录本身不会变，但它解析到的Pod的IP地址，并不是固定的。这就意味着，对于“有状态应用”实例的访问，你必须使用DNS记录或者hostname的方式，而绝不应该直接访问这些Pod的IP地址。</p><p>如果用一句话来总结的话，你可以这么理解这个过程：</p><blockquote><p>StatefulSet这个控制器的主要作用之一，就是使用Pod模板创建Pod的时候，对它们进行编号，并且按照编号顺序逐一完成创建工作。而当StatefulSet的“控制循环”发现Pod的“实际状态”与“期望状态”不一致，需要新建或者删除Pod进行“调谐”的时候，它会严格按照这些Pod编号的顺序，逐一完成这些操作。与此同时，通过Headless Service的方式，StatefulSet为每个Pod创建了一个固定并且稳定的DNS记录，来作为它的访问入口</p></blockquote><h4 id=存储状态>存储状态</h4><p>Kubernetes中PVC和PV的设计， <strong>实际上类似于“接口”和“实现”的思想</strong>。开发者只要知道并会使用“接口”，即：PVC；而运维人员则负责给“接口”绑定具体的实现，即：PV</p><p>通过PVC和PV及pod编号对应机制实现存储状态的一致</p><h4 id=总结>总结</h4><p><strong>StatefulSet的工作原理</strong>：</p><p><strong>首先，StatefulSet的控制器直接管理的是Pod</strong>。这是因为，StatefulSet里的不同Pod实例，不再像ReplicaSet中那样都是完全一样的，而是有了细微区别的。比如，每个Pod的hostname、名字等都是不同的、携带了编号的。而StatefulSet区分这些实例的方式，就是通过在Pod的名字里加上事先约定好的编号。</p><p><strong>其次，Kubernetes通过Headless Service，为这些有编号的Pod，在DNS服务器中生成带有同样编号的DNS记录</strong>。只要StatefulSet能够保证这些Pod名字里的编号不变，那么Service里类似于web-0.nginx.default.svc.cluster.local这样的DNS记录也就不会变，而这条记录解析出来的Pod的IP地址，则会随着后端Pod的删除和再创建而自动更新。这当然是Service机制本身的能力，不需要StatefulSet操心。</p><p><strong>最后，StatefulSet还为每一个Pod分配并创建一个同样编号的PVC</strong>。这样，Kubernetes就可以通过Persistent Volume机制为这个PVC绑定上对应的PV，从而保证了每一个Pod都拥有一个独立的Volume。</p><p>在这种情况下，即使Pod被删除，它所对应的PVC和PV依然会保留下来。所以当这个Pod被重新创建出来之后，Kubernetes会为它找到同样编号的PVC，挂载这个PVC对应的Volume，从而获取到以前保存在Volume里的数据。</p><p><strong>StatefulSet的设计思想</strong>：</p><p>StatefulSet其实就是一种特殊的Deployment，而其独特之处在于，它的每个Pod都被编号了。而且，这个编号会体现在Pod的名字和hostname等标识信息上，这不仅代表了Pod的创建顺序，也是Pod的重要网络标识（即：在整个集群里唯一的、可被访问的身份）。</p><p>有了这个编号后，StatefulSet就使用Kubernetes里的两个标准功能：Headless Service和PV/PVC，实现了对Pod的拓扑状态和存储状态的维护。</p><h3 id=容器化守护进程daemonset>容器化守护进程DaemonSet</h3><p>参考资料</p><p><a href=https://time.geekbang.org/column/intro/100015201>深入剖析 Kubernetes</a></p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/k8s/ rel=tag>k8s</a></li></ul></div></footer></article></main><div class="authorbox clearfix"><figure class=authorbox__avatar><img alt="techzealot avatar" src=/images/avatar.jpg class=avatar height=90 width=90></figure><div class=authorbox__header><span class=authorbox__name>关于 techzealot</span></div><div class=authorbox__description>What I cannot create, I do not understand.</div></div><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/posts/%E7%B2%BE%E5%93%81%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/ rel=prev><span class=pager__subtitle>«&#8201;上一篇</span><p class=pager__title>精品学习资料</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/posts/docker%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ rel=next><span class=pager__subtitle>下一篇&#8201;»</span><p class=pager__title>Docker知识总结</p></a></div></nav></div><aside class=sidebar><div class="widget-recent widget"><h4 class=widget__title>近期文章</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/posts/servicemesh%E6%80%BB%E7%BB%93/>ServiceMesh总结</a></li><li class=widget__item><a class=widget__link href=/posts/docker%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/>Docker知识总结</a></li><li class=widget__item><a class=widget__link href=/posts/k8s%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/>K8S知识总结</a></li><li class=widget__item><a class=widget__link href=/posts/%E7%B2%BE%E5%93%81%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/>精品学习资料</a></li><li class=widget__item><a class=widget__link href=/posts/priorityqueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>PriorityQueue源码分析</a></li><li class=widget__item><a class=widget__link href=/posts/arraydeque%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>ArrayDeque源码分析</a></li><li class=widget__item><a class=widget__link href=/posts/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/>领域驱动设计笔记</a></li><li class=widget__item><a class=widget__link href=/posts/linkedlist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>LinkedList源码分析</a></li><li class=widget__item><a class=widget__link href=/posts/arraylist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>ArrayList源码分析</a></li><li class=widget__item><a class=widget__link href=/posts/idea%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87%E4%BD%BF%E7%94%A8/>idea测试覆盖率使用</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>分类</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/categories/ddd/>DDD</a>&nbsp;
<span class="widget__counter widget__counter--bubble">1</span></li><li class=widget__item><a class=widget__link href=/categories/docker/>docker</a>&nbsp;
<span class="widget__counter widget__counter--bubble">1</span></li><li class=widget__item><a class=widget__link href=/categories/idea/>idea</a>&nbsp;
<span class="widget__counter widget__counter--bubble">1</span></li><li class=widget__item><a class=widget__link href=/categories/java/>java</a>&nbsp;
<span class="widget__counter widget__counter--bubble">5</span></li><li class=widget__item><a class=widget__link href=/categories/jcf/>JCF</a>&nbsp;
<span class="widget__counter widget__counter--bubble">4</span></li><li class=widget__item><a class=widget__link href=/categories/k8s/>k8s</a>&nbsp;
<span class="widget__counter widget__counter--bubble">1</span></li><li class=widget__item><a class=widget__link href=/categories/%E5%AE%B9%E5%99%A8/>容器</a>&nbsp;
<span class="widget__counter widget__counter--bubble">2</span></li><li class=widget__item><a class=widget__link href=/categories/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/>服务网格</a>&nbsp;
<span class="widget__counter widget__counter--bubble">1</span></li></ul></div></div><div class="widget-taglist widget"><h4 class=widget__title>标签</h4><div class=widget__content><a class="widget-taglist__link widget__link btn" href=/tags/arraydeque/ title=ArrayDeque>ArrayDeque (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/arraylist/ title=ArrayList>ArrayList (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/coverage/ title=coverage>coverage (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/ddd/ title=DDD>DDD (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/docker/ title=docker>docker (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/idea/ title=idea>idea (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/k8s/ title=k8s>k8s (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/linkedlist/ title=LinkedList>LinkedList (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/priorityqueue/ title=PriorityQueue>PriorityQueue (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/test/ title=test>test (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/ title=微服务>微服务 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%9C%80%E5%B0%8F%E5%A0%86/ title=最小堆>最小堆 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/ title=服务网格>服务网格 (1)</a></div></div><div class="widget-social widget"><h4 class="widget-social__title widget__title">社交</h4><div class="widget-social__content widget__content"><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=GitHub rel="noopener noreferrer" href=https://github.com/techzealot target=_blank><svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0C85.9.0.0 85.8.0 191.7c0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2.0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8.0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7.0.0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4.0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5.0 25.6-.2 46.3-.2 52.6.0 5.1 3.5 11.1 13.2 9.2C329 348.2 384 276.4 384 191.7 384 85.8 298 0 192 0z"/></svg><span>GitHub</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Email href=mailto:techzealot@foxmail.com><svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16V16 0h-16H16 0zm347 16-139 92.5L69 32zM199 157.5l9 5.5 9-5.5L384 46v210H32V46z"/></svg><span>techzealot@foxmail.com</span></a></div></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2023 个人博客.
<span class=footer__copyright-credits>基于 <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> 引擎和 <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> 主题</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>