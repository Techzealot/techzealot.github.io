<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on 个人博客</title><link>https://techzealot.github.io/categories/java/</link><description>Recent content in java on 个人博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 26 Jul 2023 18:26:00 +0800</lastBuildDate><atom:link href="https://techzealot.github.io/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>字符串常量池</title><link>https://techzealot.github.io/posts/java/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/</link><pubDate>Tue, 28 Mar 2023 15:14:46 +0800</pubDate><guid>https://techzealot.github.io/posts/java/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/</guid><description>Java字符串常量池 本文讨论的是JDK8及之后的版本
内存模型的变化 jdk8之后字符串常量池从Perm区转移到堆中
intern机制的变化 如果字符串常量池中存在(StringTable在比较时equals返回true)，则返回该字符串对象地址；
如果字符串常量池中不存在，则返回调用intern的字符串对象在堆中的地址，达到复用该对象
字符串常量池的添加方式 通过双引号字符串声明添加 //创建一个对象 String s = &amp;#34;test&amp;#34;; //创建hello,world两个字符串常量池中对象，两个栈中中间变量，一个堆中最终变量&amp;#34;helloworld&amp;#34;,注意此字符串不在常量池中 String s = new String(&amp;#34;hello&amp;#34;) + new String(&amp;#34;world&amp;#34;); 通过intern方法添加 //常量池不存在时 String s = new String(&amp;#34;hello&amp;#34;) + new String(&amp;#34;world&amp;#34;); s.</description></item><item><title>JUC</title><link>https://techzealot.github.io/posts/concurrent/juc/juc/</link><pubDate>Tue, 14 Mar 2023 17:04:24 +0800</pubDate><guid>https://techzealot.github.io/posts/concurrent/juc/juc/</guid><description>JUC JUC知识体系 @startmindmap * juc ** base *** unsafe *** varhandle *** volatile ** atomic *** AtomicInteger *** AtomicBoolean *** AtomicLong *** AtomicReference *** AtomicMarkablereference *** AtomicStampedReference *** AtomicXXXArray *** AtomicXXXFieldUpdater *** LongAdder/DoubleAdder *** LongAccumulator/DoubleAccumulator ** Locks *** AQS *** ReentrantLock *** ReentrantReadWriteLock *** StampedLock ** uitls *** CountdownLatch *** CyclicBarrier *** Semaphore *** Exchanger *** Phaser ** Containers *** BlockingQueue **** ArrayBlockingQueue **** LinkedBlockingQueue **** PriorityBlockingQueue **** SynchronusQueue ***** TransferQueue ***** TransferStack **** DelayQueue *** BlockingDeque **** LinkedBlockingDeque *** TransferQueue **** LinkedTransferQueue *** CopyOnWrite **** CopyOnWriteArrayList **** CopyOnWriteArraySet *** Concurrent **** ConcurrentLinkedDeque **** ConcurrentLinkedQueue **** ConcurrentSkipListSet **** ConcurrentSkipListMap **** ConcurrentHashMap ** ThreadPool *** ThreadPoolExecutor *** ScheduledThreadPoolExecutor *** ForkJoinPool ** Async *** Future **** FutureTask(Treiber Stack) *** CompletableFuture @endmindmap Synchronized 使用wait/notifyAll,Lock/Condition实现阻塞队列 实现锁的核心要素 为了实现一把具有阻塞或唤醒功能的锁，需要几个核心要素：</description></item><item><title>PriorityQueue源码分析</title><link>https://techzealot.github.io/posts/jcf/priorityqueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Thu, 11 Aug 2022 13:55:39 +0800</pubDate><guid>https://techzealot.github.io/posts/jcf/priorityqueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>本质是一个最小二叉堆,底层使用数组进行存储
使用到的二叉堆性质:(n为二叉堆节点个数,数组从索引0开始存储,从上到下从左到右从0开始依次编号)
节点i若有左右孩子，则左孩子索引为(i&amp;laquo;1)+1,右孩子索引为(i&amp;laquo;1)+2
第一个叶子结点的索引为size&amp;raquo;1,最后一个非叶子节点索引为(size&amp;raquo;1)-1
节点i的父节点为(i-1)&amp;raquo;1,若(i&amp;laquo;1)+1 &amp;gt;=size(无左孩子)则该节点一定为叶子结点
叶子结点在数组后半段且从第一个叶子结点开始后续全都是叶子结点
初始化注意事项:</description></item><item><title>ArrayDeque源码分析</title><link>https://techzealot.github.io/posts/jcf/arraydeque%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Thu, 11 Aug 2022 13:55:08 +0800</pubDate><guid>https://techzealot.github.io/posts/jcf/arraydeque%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>本质: 循环数组，支持双端存取
JDK8中底层数组的大小必须为2的n次幂有多个好处:
2.1 方便按顺序遍历数组中所有元素
int mask=elements.</description></item><item><title>Springboot参数校验及异常处理</title><link>https://techzealot.github.io/posts/java/springboot%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link><pubDate>Wed, 26 Jul 2023 18:26:00 +0800</pubDate><guid>https://techzealot.github.io/posts/java/springboot%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid><description>Springboot参数校验及相关异常处理 不同类型参数校验 实体添加校验规则
@Data public class User { @NotNull(message = &amp;#34;name不能为空&amp;#34;) private String name; @Range(min = 0, max = 120, message = &amp;#34;必须在0-120之间&amp;#34;) private int age; } 通过query string传递的参数 需要在Controller上加上@Validated注解否则不会触发校验规则</description></item><item><title>LinkedList源码分析</title><link>https://techzealot.github.io/posts/jcf/linkedlist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Fri, 05 Aug 2022 17:59:57 +0800</pubDate><guid>https://techzealot.github.io/posts/jcf/linkedlist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description> 本质: 双向链表 序列化时仅需要按顺序序列化元素本身无需序列化Node，只需要在反序列化时重建双向链表即可 不推荐作为Deque,Queue,Stack(不允许存储null)使用,因为LinkedList可以存储null,不符合取出元素返回null时集合为空的接口定义</description></item><item><title>ArrayList源码分析</title><link>https://techzealot.github.io/posts/jcf/arraylist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Fri, 05 Aug 2022 17:59:47 +0800</pubDate><guid>https://techzealot.github.io/posts/jcf/arraylist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description> 本质:底层使用数组，超出数组容量后会扩容50%并将数据拷贝到新数组对应位置 序列化的优化:仅序列化存有元素的数据,不序列化未使用数组部分 使用modCount做简化的并发检测，并不能做到并发安全，可以控制使用迭代器时无法修改集合，仅能通过迭代器提供的操作进行处理 Collection#toArray接口要求返回一个新的存有集合数据的数组，不能返回底层数组防止被意外修改影响原集合功能</description></item><item><title>idea测试覆盖率使用</title><link>https://techzealot.github.io/posts/misc/idea%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87%E4%BD%BF%E7%94%A8/</link><pubDate>Wed, 22 Dec 2021 14:25:05 +0800</pubDate><guid>https://techzealot.github.io/posts/misc/idea%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87%E4%BD%BF%E7%94%A8/</guid><description>单个测试覆盖率
直接选择&amp;quot;Run with Coverage&amp;quot;即可
所有测试的覆盖率(gradle)
在gradle插件中找到test任务(Tasks/verification/test),右键test选择&amp;quot;Run with Coverage&amp;quot;即可</description></item></channel></rss>