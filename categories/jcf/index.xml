<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JCF on 个人博客</title><link>https://techzealot.github.io/categories/jcf/</link><description>Recent content in JCF on 个人博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 11 Aug 2022 13:55:39 +0800</lastBuildDate><atom:link href="https://techzealot.github.io/categories/jcf/index.xml" rel="self" type="application/rss+xml"/><item><title>PriorityQueue源码分析</title><link>https://techzealot.github.io/posts/priorityqueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Thu, 11 Aug 2022 13:55:39 +0800</pubDate><guid>https://techzealot.github.io/posts/priorityqueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>本质是一个最小二叉堆,底层使用数组进行存储
使用到的二叉堆性质:(n为二叉堆节点个数,数组从索引0开始存储,从上到下从左到右从0开始依次编号)
节点i若有左右孩子，则左孩子索引为(i&amp;laquo;1)+1,右孩子索引为(i&amp;laquo;1)+2
第一个叶子结点的索引为size&amp;raquo;1,最后一个非叶子节点索引为(size&amp;raquo;1)-1
节点i的父节点为(i-1)&amp;raquo;1,若(i&amp;laquo;1)+1 &amp;gt;=size(无左孩子)则该节点一定为叶子结点
叶子结点在数组后半段且从第一个叶子结点开始后续全都是叶子结点
初始化注意事项:</description></item><item><title>ArrayDeque源码分析</title><link>https://techzealot.github.io/posts/arraydeque%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Thu, 11 Aug 2022 13:55:08 +0800</pubDate><guid>https://techzealot.github.io/posts/arraydeque%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>本质: 循环数组，支持双端存取
JDK8中底层数组的大小必须为2的n次幂有多个好处:
2.1 方便按顺序遍历数组中所有元素
int mask=elements.</description></item><item><title>LinkedList源码分析</title><link>https://techzealot.github.io/posts/linkedlist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Fri, 05 Aug 2022 17:59:57 +0800</pubDate><guid>https://techzealot.github.io/posts/linkedlist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description> 本质: 双向链表 序列化时仅需要按顺序序列化元素本身无需序列化Node，只需要在反序列化时重建双向链表即可 不推荐作为Deque,Queue,Stack(不允许存储null)使用,因为LinkedList可以存储null,不符合取出元素返回null时集合为空的接口定义</description></item><item><title>ArrayList源码分析</title><link>https://techzealot.github.io/posts/arraylist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Fri, 05 Aug 2022 17:59:47 +0800</pubDate><guid>https://techzealot.github.io/posts/arraylist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description> 本质:底层使用数组，超出数组容量后会扩容50%并将数据拷贝到新数组对应位置 序列化的优化:仅序列化存有元素的数据,不序列化未使用数组部分 使用modCount做简化的并发检测，并不能做到并发安全，可以控制使用迭代器时无法修改集合，仅能通过迭代器提供的操作进行处理 Collection#toArray接口要求返回一个新的存有集合数据的数组，不能返回底层数组防止被意外修改影响原集合功能</description></item></channel></rss>